#!/usr/bin/env python

from __future__ import print_function
from __future__ import division

import argparse
import subprocess
import os
import sys
import errno
import copy
import re
import math
import atexit

# Handle Python 3 DBM module
try:
    import anydbm as dbm
except ImportError:
    import dbm

multiplicator_lookup = ['B', 'K', 'M', 'G', 'T', 'P']
BLK_FORMAT="%01.0f"
SMALL_BLK_FORMAT="%01.1f"
PERC_FORMAT="%01.0f"
LIMIT_DBM_FILE = '/var/lib/misc/pybtrfs_qgroup_limit.dbm'
BTRFS = '/sbin/btrfs'
DF = '/bin/df'
BTRFS_QGROUP_VER = float('0.20')
BTRFS_QGROUP_LIMIT_DISPLAY_VER = float('3.12')
progname = os.path.basename(sys.argv[0])
db = None    


# Deal with missing function from v2.6 subprocess module
try:
    from subprocess import check_output
except ImportError:
    def check_output(*popenargs, **kwargs):
        r"""Run command with arguments and return its output as a byte string.

        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.

        The arguments are the same as for the Popen constructor. Example:

        >>> check_output(["ls", "-l", "/dev/null"])
        'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'

        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.

        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        'ls: non_existent_file: No such file or directory\n'
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
        process = subprocess.Popen(stdout=subprocess.PIPE, *popenargs, **kwargs)
        output, unused_err = process.communicate()
        retcode = process.poll()
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
            raise subprocess.CalledProcessError(retcode, cmd)
        return output

def get_btrfs_tools_version():
    """
    Get BTRFS versioning
    """
    cmd = [BTRFS, '--version']
    cmd_output = cmd_stdout(cmd, exit_on_error=False, suppress_stderr=True)
    cmd_output = cmd_output.splitlines()
    version_line = [ line for line in cmd_output if line[:5] == 'Btrfs']
    if (len(version_line) != 1):
        print("%s: Can't determine btrfs progs version." % progname, file=sys.stderr)
        sys.exit(os.EX_SOFTWARE)
    try:
        version = version_line[0].split()[1]
        ver_re = re.compile(r'^v([0-9\.]+)\S+$')
        version = ver_re.sub(r'\1', version)
        version = float(version)
    except:
        print("%s: Can't determine btrfs progs version." % progname, file=sys.stderr)
        sys.exit(os.EX_SOFTWARE)
    return version

def parse_quota_display_args():
    parser = argparse.ArgumentParser(prog=progname+' quota display',
        description='Displays quota groups from a BTRFS filesystem readably'
    )
    parser.add_argument(
        '-u', '--unit', metavar='U', type=str,
        default='G',
        help='SI Unit, [B]ytes, K, M, G, T, P',
    )
    parser.add_argument(
        'mount_point', metavar='PATH', type=str,
        default='/',
        help='BTRFS mount point',
    )
    sys.argv.pop(2)
    sys.argv.pop(1)
    result = dict()
    result = parser.parse_args()
    return result

def close_db():
    """
    Clean up open dbm data base
    """

    global db
    
    if db:
        db.close()
    return None

atexit.register(close_db)

def get_limit(path_key):
    
    global db

    try:
        db = dbm.open(LIMIT_DBM_FILE, 'r')
    except dbm.error:
        db = None
    except (OSError, IOError) as exc:
        if (errno == errno.ENOENT):
            db = None
        else:
            raise exc

    if (not db):
        return None
    if (path_key is None):
        return None
    if (path_key[0] == '@'):
        path_key = '/' + path_key[1:]
    elif path_key[0] != '/':
        path_key = '/' + path_key
    try:
        limit = db[path_key]
        unit = limit[-1]
        amount = int(limit[:-1])
        limit = amount * 1024 ** multiplicator_lookup.index(unit)
    except:
        limit = None
    return limit

def cmd_stdout(cmd, exit_on_error=True, suppress_stderr=False):
    try:
        process = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE,
                            bufsize=1, close_fds=True, )
        (cmd_output, cmd_stderr) = process.communicate()
        retcode = process.poll()
        if (exit_on_error and retcode != 0):
            if cmd_stderr:
                print(cmd_stderr, file=sys.stderr)
            sys.exit(retcode)
            
    except (OSError, IOError) as exc:
        print("%s: %s - %s." % (progname, cmd[0], exc.strerror), file=sys.stderr)
        if (exc.errno in (errno.EACCES, errno.EEXIST)):
            sys.exit(os.EX_OSFILE)
        elif (exc.errno in (errno.EPERM,)):
            sys.exit(os.EX_NOPERM)
        else:
            sys.exit(os.EX_OSERR)
    if (not(suppress_stderr) and cmd_stderr):
        print(cmd_stderr, file=sys.stderr)

    return cmd_output
        

def do_quota_display(parse_args):

    subvolume_data = dict()
    cmd = [BTRFS,  "subvolume", "list", parse_args.mount_point]
    for line in check_output(cmd).splitlines():
        args = line.strip().split(' ')
        subvolume_data[int(args[1])] = args[-1]

    
    cmd = [BTRFS, "qgroup", "show"]
    if (btrfs_tools_version >= BTRFS_QGROUP_LIMIT_DISPLAY_VER):
       cmd.append('-r')
    cmd.append(parse_args.mount_point)

    try:
        cmd_output =  check_output(cmd, stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError as exc:
        print("%s: btrfs quota not enabled on '%s'" % (progname, parse_args.mount_point),
                file=sys.stderr)
        sys.exit(exc.returncode)

    print("subvol\t\t\t\t    group         total       limit    unshared")
    print("-" * 79)
    for line in cmd_output.splitlines():
        args = [x for x in line.strip().split(' ') if len(x)>0]

        if args[0] in ('qgroupid', '--------'):
             # Skip column headers
             continue

        try:
            subvolume_id = args[0].split('/')[-1]
            subvolume_name = subvolume_data[int(subvolume_id)]
        except:
            subvolume_name = "(unknown)"

        # Get limit out of DBM file
        subvol = subvolume_data.get(int(subvolume_id))
        if (btrfs_tools_version >= BTRFS_QGROUP_LIMIT_DISPLAY_VER):
            try:
                limit = float(args[3])
            except (TypeError, ValueError):
                limit = None
        else:
            limit = get_limit(subvol)
        if (limit is None):
            limit = '--'
            limit_unit = '-'
        else:
            limit_unit = parse_args.unit

        multiplicator = 1024 ** multiplicator_lookup.index(parse_args.unit)

        try:
            try:
                total = BLK_FORMAT % (float(args[1]) / multiplicator)
                unshared = BLK_FORMAT % (float(args[2]) / multiplicator)
                if (limit != '--'):
                    limit = BLK_FORMAT % (float(limit) / multiplicator)
            except ValueError:
                continue
            
            format_args = [
                subvolume_name.ljust(30),
                str(args[0]).rjust(10),
                total.rjust(10), parse_args.unit,
                limit.rjust(10), limit_unit,
                unshared.rjust(10), parse_args.unit
            ]
            print("%s  %s  %s%s %s%s %s%s" % tuple(format_args))
        except IndexError:
            pass
    
    return 0

def parse_qgroup_limit_args():
    parser = argparse.ArgumentParser(prog=progname+' qgroup limit',
        description='Set qgroup limits on a BTRFS file system subvolume'
    )
    parser.add_argument(
        '-c', action='store_const', const='-c',
        help='limit amount of data after compression. This is the default, ' \
         'it is currently not possible to turn off this option.',
    )
    parser.add_argument(
        '-e', action='store_const', const='-e',
        help='limit space exclusively assigned to this qgroup',
    )
    parser.add_argument(
        'size', metavar='SIZE|none', type=str,
        default='none',
        help='qgroup size limit',
    )
    parser.add_argument(
        'qgroupid', metavar='qgroupid', type=str, nargs='?',
        default=None,
        help='qgroup size limit',
    )
    parser.add_argument(
        'mount_point', metavar='PATH', type=str,
        default='/',
        help='BTRFS mount point',
    )

    sys.argv.pop(2)
    sys.argv.pop(1)
    result = parser.parse_args()
    return result

def do_qgroup_limit(parse_args):

    cmd = [BTRFS, 'qgroup', 'limit']
    if parse_args.e:
        cmd.append(parse_args.e)
    if parse_args.c:
        cmd.append(parse_args.c)
    cmd.append(parse_args.size)
    if parse_args.qgroupid:
        cmd.append(parse_args.qgroupid)
    cmd.append(parse_args.mount_point)
    exit_code = subprocess.check_call(cmd)
  
    if (exit_code != 0):
        sys.exit(exit_code)

    db = dbm.open(LIMIT_DBM_FILE, 'c')
    if (parse_args.size and parse_args.size != 'none'):
        db[parse_args.mount_point] = parse_args.size.upper()
    elif (not parse_args.size or parse_args.size == 'none'):
        try:
            db.pop(parse_args.mount_point)
        except KeyError:
            pass
    db.close()

    return exit_code

def parse_qgroup_prune_args():
    parser = argparse.ArgumentParser(prog=progname+' qgroup prune',
        description='Prune unattached qgroups from a BTRFS file system'
    )
    parser.add_argument(
        'mount_point', metavar='PATH', type=str,
        default='/',
        help='BTRFS mount point',
    )

    sys.argv.pop(2)
    sys.argv.pop(1)
    result = parser.parse_args()
    return result

def do_qgroup_prune(parse_args):
    
    subvolume_names = dict()
    subvolume_data = dict()


    cmd = [BTRFS, "qgroup", "show", parse_args.mount_point]
    try:
        cmd_output = check_output(cmd, stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError as exc:
        # Commented out so that command can be used from crontab
        #print("%s: btrfs quota not enabled on '%s'" % (progname, parse_args.mount_point),
        #        file=sys.stderr)
        #sys.exit(exc.returncode)
        sys.exit(os.EX_OK)


    cmd = [BTRFS,  "subvolume", "list", parse_args.mount_point]
    for line in check_output(cmd).splitlines():
        args = line.strip().split(' ')
        subvolume_data[int(args[1])] = args[-1]

    for line in cmd_output.splitlines():
        args = [x for x in line.strip().split(' ') if len(x)>0]

        try:
            subvolume_id = args[0].split('/')[-1]
            subvolume_name = subvolume_data[int(subvolume_id)]
        except:
            subvolume_name = None
        
        if (not subvolume_name):
            subprocess.check_call([BTRFS, 'qgroup', 'destroy', args[0], 
                parse_args.mount_point])
        else:
            subvolume_names[subvolume_name] = subvolume_id
        
    # Prune DBM file
    db = dbm.open(LIMIT_DBM_FILE, 'c')
    existing_subvols = subvolume_names.keys()
    delete_subvols = []
    for k, v in db.iteritems():
        if (k[1:] in existing_subvols):
            continue
        delete_subvols.push(k)
    for k in delete_subvols:
        db.pop(k)
    db.close()
    return 0

def format_bytes(bytes, pwr3_base, unit, human_output):
    """
    Take bytes, and produce printable string output
    """
    unit_output = False
    if human_output:
        unit_output = True
        pwr_of = int(math.log(bytes, pwr3_base))
        unit = multiplicator_lookup[pwr_of]
    elif unit:
        unit_output = False
        pwr_of = multiplicator_lookup.index(unit)

    if (unit and pwr3_base == 1000 and not human_output):
        unit_output = True
        unit += 'B'
    out_num = bytes / pwr3_base ** pwr_of
    
    blk_format = BLK_FORMAT
    if (out_num < 10):
        blk_format = SMALL_BLK_FORMAT

    if unit_output:
        out_string = (blk_format % out_num) + unit
    else:
        out_string = (blk_format % out_num)
    return (out_string)

class UnitAction(argparse.Action):
    unit = 'K'
    pwr3_base = 1024
    human_output = False

    def __init__(self, option_strings, dest, **kwargs):
        super(UnitAction, self).__init__(option_strings, dest, **kwargs)

    def __call__(self, parser, namespace, values, option_string=None):
        # print '%r %r %r' % (namespace, values, option_string)
        # setattr(namespace, self.dest, values)

        unit = self.unit
        pwr3_base = self.pwr3_base
        human_output = self.human_output

        if values and type(values) in (list, tuple):
            block_size = values[0]
        elif values:
            block_size = values
        else:
            block_size = None

        if (option_string in ('-B', '--block-size')):
            if (block_size == '1000000000000000000'):
                unit = 'E'
                pwr3_base = 1000
            elif (block_size == '1000000000000000'):
                unit = 'P'
                pwr3_base = 1000
            elif (block_size == '1000000000000'):
                unit = 'T'
                pwr3_base = 1000
            elif (block_size == '1000000000'):
                unit = 'G'
                pwr3_base = 1000
            elif (block_size == '1000000'):
                unit = 'M'
                pwr3_base = 1000
            elif (block_size == '1000'):
                unit = 'K'
                pwr3_base = 1000
            elif (len(block_size) == 3 and (block_size[0] in multiplicator_lookup) 
                    and block_size[1:-1] == 'iB'):
                unit = block_size[0]
                pwr3_base = 1024
            elif (len(block_size) == 2 and (block_size[0] in multiplicator_lookup) 
                    and block_size[1] == 'B'):
                unit = block_size[0]
                pwr3_base = 1000
            elif (len(block_size) == 1 and (block_size[0] in multiplicator_lookup)):
                unit = block_size[0]
                pwr3_base = 1024
            else:
                print("%s: incorrect -B/--blocksize argument '%s' - see man (1) df SIZE" 
                        % (progname, block_size));
                sys.exit(os.EX_USAGE)
            value = unit
        elif (option_string in ('-m', '--megabytes')):
            value = True
            unit = 'M'
            pwr3_base = 1024
        elif (option_string in ('-k', '--kilobytes')):
            value = True
            unit = 'K'
            pwr3_base = 1024
        elif (option_string in ('-h', '--human-readable')):
            value = True
            unit = ''
            human_output = True
            pwr3_base = 1024
        elif (option_string in ('-H', '--si')):
            value = True
            human_output = True
            unit = ''
            pwr3_base = 1000
        
        setattr(namespace, self.dest, value)
        setattr(namespace, 'unit', unit)
        setattr(namespace, 'pwr3_base', pwr3_base)
        setattr(namespace, 'human_output', human_output)

def parse_df_args():
    """
    Pybtrfs df argument handling
    """
    parser = argparse.ArgumentParser(prog=progname+' df',
        description='Df including BTRFS Metadata, Data, and System space',
        conflict_handler='resolve'
    )
    parser.add_argument(
        '-A', '--btrfs-all', action='store_true',
        help="All BTRFS metadata/system/data details"
    )
    parser.add_argument(
        '-l', '--local', action='store_true',
        help='Only do local file systems',
    )
    parser.add_argument(
        '-h', '--human-readable', nargs='?',  action=UnitAction, default=False,
        help='Human readable output GiB/MiB/KiB',
    )
    parser.add_argument(
        '-H', '--si', action=UnitAction, nargs='?', default=False,
        help='Human readable output GB/MB/KB',
    )
    parser.add_argument(
        '-m', '--megabytes', nargs='?', action=UnitAction, default=False,
        help='Output MiB',
    )
    parser.add_argument(
        '-k', '--kilobytes', nargs='?', action=UnitAction, default=False,
        help='Output KiB',
    )
    parser.add_argument(
        '-T', '--print-type', action='store_true',
        help='Output file system type',
    )
    parser.add_argument(
        '-B', '--block-size', action=UnitAction, default=None,
        nargs='?',
        help='Scales output by SIZE B/K/M/G/T',
    )
    parser.add_argument(
        '-t', '--type', action='store',
        nargs='?', default='all',
        help='File system type',
    )
    parser.add_argument(
        'path', metavar='PATH', type=str,
        #default='/', nargs='?',
        nargs='*',
        help='Path for df',
    )
    sys.argv.pop(1)
    parse_args = parser.parse_args()
    # Process and determine unit for results
    try:
        thing = getattr(parse_args, 'unit')
    except AttributeError:
        setattr(parse_args, 'unit', 'K')
    try:
        thing = getattr(parse_args, 'pwr3_base')
    except AttributeError:
        setattr(parse_args, 'pwr3_base', 1024)
    try:
        thing = getattr(parse_args, 'human_output')
    except AttributeError:
        setattr(parse_args, 'human_output', False)
    return parse_args

def do_df(parse_args):
    """
    Pybtrfs df action.  This is the business end where df output and btrfs
    output are evaluated and intermingled.
    """
    def convert_args(parse_args, working_set):
        """
        Convert input parse_args into df_arg_list
        """
        # working_set['df_arg_list'] = df_arg_list
        working_set['df_arg_list'] = [arg for arg in sys.argv[1:] 
                                        if arg not in ('-A', '--btrfs-all')]

        working_set['df_fs_list'] = [arg for arg in working_set['df_arg_list'] 
                                                if arg[0] != '-']

        return 0

    def scan_btrfs(parse_args, working_set):

        cmd = ['/sbin/blkid']
        blkid_output = cmd_stdout(cmd)
        blkid_output = blkid_output.splitlines()
        blkids = {}
        for line in blkid_output:
            dev, rest = line.split(':',1)
            blkid = {}
            blkids[dev] = blkid
            rest = rest.strip()
            rest = rest.split('" ')
            for b in rest:
                thing = b.split('=')
                if thing[1][-1] == '"':
                    blkid[thing[0].lower()] = thing[1][1:-1]
                else:
                    blkid[thing[0].lower()] = thing[1][1:]
        working_set['blkid'] = blkids

        btrfs_blkid_devs = [d for d in blkids.keys() 
                                if blkids[d]['type'] == 'btrfs']
        working_set['btrfs_blkid_devs'] = btrfs_blkid_devs

        btrfs_mnt_devs = {}
        mounts = open('/proc/mounts', 'r')
        for line in mounts:
            if (line.find('btrfs') == -1):
                continue
            mount_line = line.split()
            btrfs_mnt_devs[mount_line[1]] = mount_line[0]
        working_set['btrfs_mnt_devs'] = btrfs_mnt_devs
        mounts.close()

        subvol_mounts = []
        btrfs_mounts = []
        first = True
        for dev in btrfs_blkid_devs:
            fstab = open('/etc/fstab', 'r')
            for line in fstab:
                if (line.find('btrfs') == -1):
                    continue
                fstab_line = line.split()
                line_dev = btrfs_mnt_devs.get(fstab_line[1])
                if (not line_dev):
                    continue
                if (line_dev != dev):
                    continue
                if first:
                    first = False
                    btrfs_mounts.append(fstab_line[1])
                    continue
                subvol_mounts.append(fstab_line[1])
            fstab.close()
            first = True
       
        def fn_sort(x,y): return(cmp(len(x), len(y)));
        btrfs_mounts.sort(fn_sort)

        working_set['subvol_mounts'] = subvol_mounts
        working_set['btrfs_mounts'] = btrfs_mounts

    def run_df(parse_args, working_set):
        """
        Run df with -T, capture output
        """
        # Work out args to give to df
        cmd = [DF, '-T']
        cmd.extend(working_set['df_arg_list'])
        df_output = cmd_stdout(cmd)
        size_re = re.compile(r'^(\S+\s+\S+\s+)(\S+)(\s+.*)$')
        available_re = re.compile(r'^(\S+\s+\S+\s+\S+\s+\S+\s+)(\S+)(\s+.*)$')
        df_output = df_output.splitlines()
        df_header = df_output[0]
        df_header_sizeword = size_re.sub(r'\2', df_header)
        df_header = size_re.sub(r'\1Size\3', df_header)
        df_header_availableword = available_re.sub(r'\2', df_header)
        df_header = available_re.sub(r'\1Available\3', df_header)
        df_output = [x for x in df_output if (x[0] in ('/',) or x[:2] == '- ')]
        df_output.insert(0, df_header)
        df_output = [x.split(None, 6) for x in df_output]
        df_output_dict = {'df_header': dict(zip(df_output[0], df_output[0]))}
        df_output_dict['df_header']['Size'] = df_header_sizeword
        df_output_dict['df_header']['Available'] = df_header_availableword
        for fs in df_output[1:]:
            entry = dict(zip(df_output[0], fs))
            if (entry['Type'] != 'btrfs' and entry['Filesystem'] != '-'):
                df_output_dict[entry['Mounted on']] = entry
                continue
            
            # Working with BTRFS FS output
            mpt = entry['Mounted on']
            mpts = [ m for m in working_set['btrfs_mounts'] if mpt.find(m) != -1 ]
            if (len(mpts)):
                entry['Mounted on'] = max(mpts, key=len)
                entry['Filesystem'] = working_set['btrfs_mnt_devs'][entry['Mounted on']] 
                entry['Type'] = 'btrfs'
                entry['UUID'] = working_set['blkid'].get(entry['Filesystem']).get('UUID')
                entry['blkid'] = working_set['blkid'].get(entry['Filesystem'])
                df_output_dict[entry['Mounted on']] = entry
                continue
        working_set['df_output_dict'] = df_output_dict

        return 0

    def get_btrfs_mounts(parse_args, working_set):
        """
        Get btrfs mount points
        """
        # read in /etc/fstab so that we can deal with subvol mounts
        subvol_mount = []
        btrfs_list = []
        for k in working_set["df_output_dict"]:
            fs = working_set["df_output_dict"][k]
            if fs['Type'] != 'btrfs':
                continue
            # Match to most specific BTRFS mount pount
            mpt = fs['Mounted on']
            mpts = [ m for m in working_set['btrfs_mounts'] if mpt.find(m) != -1 ]
            if (len(mpts)):
                real_mpt = max(mpts, key=len)
                fs['Mounted on'] = real_mpt
            # find real file system device
            fs['real_dev'] = os.path.realpath(fs['Filesystem'])
            btrfs_list.append(fs)

        working_set['btrfs_list'] = btrfs_list
        return 0

    def to_bytes(amount):
        if amount[-1] in multiplicator_lookup:
            unit = amount[-1]
            amount = float(amount[:-1])
        else:
            unit = 'B'
            amount = float(amount)
        bytes = amount * 1024 ** multiplicator_lookup.index(unit)
        return bytes

    def map_eval(o):
        o['used'] = to_bytes(o['used'])
        o['total'] =  to_bytes(o['total'])
        o['use_%'] = (100 * (o['used']/o['total']))
        return(o)

    def do_btrfs_fi_df(parse_args, working_set):
        """
        3) For each btrfs FS run btrfs filesystem df

        4) Analyse btrfs fi df output

        5) Put into df output
        """
        if (not parse_args.btrfs_all):
            return os.EX_OK

        for fs in working_set['btrfs_list']:
            # For each btrfs FS run btrfs filesystem df
            cmd = [BTRFS, 'filesystem', 'df', fs['Mounted on']]
            btrfs_output = cmd_stdout(cmd)
            btrfs_output = btrfs_output.splitlines()

            output = []
            for line in btrfs_output:
                
                # Parse a line
                tag, rest = line.split(':')
                tag = tag.strip()
                total, used = rest.split(',')
                total = total.strip()
                used = used.strip()
                if total.lower().find('used') != -1:
                    tmp = used
                    used = total
                    total = tmp
                thing, total = total.split('=')
                total = total.rstrip('Bi')
                thing, used = used.split('=')
                used = used.rstrip('Bi')
            
                # Store
                output.append({'tag': tag, 'used': used, 'total': total})

            # Process into bytes and % used
            output = [map_eval(o) for o in output]
            # Sort, greatest usage first - uses a mapped function
            def fn_sort(o,p): return(cmp(o['use_%'], p['use_%']));
            output.sort(fn_sort, reverse=True)

            # determine results - System, then Metadata, then Data
            output2 = []
            system = [ o for o in output if (o['tag'].lower().find('system') != -1) ]
            if len(system):
                system = system[0]
                system['tag'] = 'system'
            else:
                system = system

            metadata = [ o for o in output if (o['tag'].lower().find('metadata') != -1) ]
            if len(metadata):
                metadata = metadata[0]
                metadata['tag'] = 'metadata'
            else:
                metadata = metadata

            # Difference of tag 'Data' from 'Metadata' - always starts with 'D'
            data = [ o for o in output if (o['tag'].find('Data') != -1) ]
            if len(data):
                data = data[0]
                data['tag'] = 'data'
            else:
                data = data
            
            output2.append(system)
            output2.append(metadata)
            if len(data):
                output2.append(data)
            output = output2

            # Scale bytes -> output
            pwr3_base = parse_args.pwr3_base
            unit = parse_args.unit
            human_output = parse_args.human_output
            for line  in output:
                line['available'] = line['total'] - line['used']
                line['used'] = format_bytes(line['used'], pwr3_base, unit, human_output)
                line['total'] = format_bytes(line['total'], pwr3_base, unit, human_output)
                line['available'] = format_bytes(line['available'], pwr3_base, unit, 
                                            human_output)
                line['use_%'] = PERC_FORMAT % line['use_%'] + '%'

            # Put results into df output
            df_output_dict = working_set['df_output_dict']
            for line in output:
                fs_mounted_on = fs['Mounted on']
                if fs_mounted_on == '/':
                    out_mounted_on = fs_mounted_on + line['tag'].upper()
                else:
                    out_mounted_on = fs_mounted_on + '/' + line['tag'].upper()

                out_dict = {'Size': line['total'],
                        'Used': line['used'],
                        'Use%': line['use_%'],
                        'Filesystem': fs['Filesystem'] + '/' + line['tag'].upper(),
                        'Available': line['available'],
                        'Mounted on': out_mounted_on,
                        'Type': fs['Type']
                        }
                df_output_dict[out_dict['Mounted on']] = out_dict

    def do_btrfs_quota_display(parse_args, working_set):
        """
        6) For each btfrs FS run btrfs qgroup show
        7) Analyse btrfs qgroup show output
        8) Insert output into congolmerated output
        """

        # See if btrfs has 'qgroup' support
        if (btrfs_tools_version < BTRFS_QGROUP_VER):
            return 0

        for fs in working_set['btrfs_list']:
            
            try:
                cmd = [BTRFS, "qgroup", "show"]
                if (btrfs_tools_version >= BTRFS_QGROUP_LIMIT_DISPLAY_VER):
                    cmd.append('-r')
                cmd.append(fs["Mounted on"])
                cmd_output = check_output(cmd, stderr=subprocess.STDOUT )
            except subprocess.CalledProcessError as exc:
                continue

            output = []
            subvolume_data = dict()
            cmd = [BTRFS,  "subvolume", "list", fs['Mounted on']]
            for line in cmd_stdout(cmd).splitlines():
                args = line.strip().split(' ')
                subvolume_data[int(args[1])] = args[-1]

            for line in cmd_output.splitlines():
                args = [x for x in line.strip().split(' ') if len(x)>0]

                try:
                    subvolume_fullid = args[0]
                    subvolume_id = args[0].split('/')[-1]
                    subvolume_name = subvolume_data[int(subvolume_id)]
                except:
                    # Go on to next one
                    continue

                # Get limit out of DBM file
                subvol = subvolume_data.get(int(subvolume_id))

                if (btrfs_tools_version >= BTRFS_QGROUP_LIMIT_DISPLAY_VER):
                    try:
                        limit = float(args[3])
                    except (TypeError, ValueError):
                        limit = None
                else:
                    limit = get_limit(subvol)
                if (limit is None or limit <= 0):
                    continue

                total = int(args[1])
                unshared = int(args[2])

                # Now have limit, and and total used in subvolume qgroup,
                # We can create line for df output.
                if (fs['Mounted on'] == '/'):
                    mounted_on = fs['Mounted on'] + subvolume_name
                else:
                    mounted_on = fs['Mounted on'] + '/' + subvolume_name
                file_system = fs['Filesystem'] + '/' + subvolume_fullid

                output.append({'Mounted on': mounted_on,
                    'Filesystem': file_system,
                    'Used': unshared,
                    'Size': limit,
                    'Available': limit - unshared,
                    'Type': fs['Type'],
                    'Use%': 100 * float(unshared/limit),
                    })

            pwr3_base = parse_args.pwr3_base
            unit = parse_args.unit
            human_output = parse_args.human_output
            for line in output:
                line['Use%'] = PERC_FORMAT % line['Use%'] + '%'
                line['Used'] = format_bytes(line['Used'], pwr3_base, unit, human_output)
                line['Size'] = format_bytes(line['Size'], pwr3_base, unit, human_output)
                line['Available'] = format_bytes(line['Available'], pwr3_base, unit, 
                                        human_output)

            df_output_dict = working_set['df_output_dict']
            for line in output:
                if working_set['df_fs_list']:
                    in_df_fs_list = [ fs for fs in working_set['df_fs_list'] 
                            if line['Mounted on'].find(fs) != -1 ]
                    if (len(in_df_fs_list) == 0):
                        continue
                df_output_dict[line['Mounted on']] = line

    def do_btrfs_filesystem_show(parse_args, working_set):
        """
        Display btrfs fs show output if df output
        """
        # Get real BTRFS mount points
        for fs in working_set['btrfs_list']:
            cmd = [BTRFS,'filesystem', 'show', fs['real_dev']]
            cmd_output = cmd_stdout(cmd).splitlines()
            output = {}
            if (fs['Mounted on'] == '/'):
                mounted_on = '/' + 'BLOCK'
            else:
                mounted_on = fs['Mounted on'] + '/' + 'BLOCK'

            # Count number of devices
            count = 0
            for line in cmd_output:
                if line.find('devid') != -1: 
                    count += 1
            for line in cmd_output:
                if (line.find('devid') == -1):
                    continue
                device = {}
                line = line.split()
                device['Size'] = to_bytes(line[3].rstrip('Bi'))
                device['Used'] = to_bytes(line[5].rstrip('Bi'))
                device['Available'] = device['Size'] - device['Used']
                device['Use%'] = 100 * float(device['Used']/device['Size'])
                device['real_dev'] = line[7]
                device['Type'] = 'btrfs'
                if (count == 1):
                    device['Filesystem'] = fs['Filesystem'] + '/' + 'BLOCK'
                else:
                    device['Filesystem'] = device['real_dev'] + '/' + 'BLOCK'
                device['Mounted on'] = mounted_on
                output[device['Filesystem']] = device

            # Convert bytes to units
            pwr3_base = parse_args.pwr3_base
            unit = parse_args.unit
            human_output = parse_args.human_output
            for dev in output:
                line = output[dev]
                line['Use%'] = PERC_FORMAT % line['Use%'] + '%'
                line['Used'] = format_bytes(line['Used'], pwr3_base, unit, human_output)
                line['Size'] = format_bytes(line['Size'], pwr3_base, unit, human_output)
                line['Available'] = format_bytes(line['Available'], pwr3_base, unit, 
                                        human_output)

            # Insert into output dict
            df_output_dict = working_set['df_output_dict']
            for device in output:
                df_output_dict[line['Mounted on']] = line

    def display_output(parse_args, working_set):
        """
        Display congolmerated output
        """
        max_len = {}
        df_header = working_set["df_output_dict"]['df_header']
        df_arg_list = working_set['df_arg_list']
        max_len = dict([(k, len(df_header[k])) for k in df_header])
        for k in working_set["df_output_dict"]:
            fs = working_set["df_output_dict"][k]
            max_len = dict([(k2, max(max_len[k2], len(fs[k2]))) for k2 in fs 
                                            if (k2 not in ('real_dev', 'UUID', 'blkid'))])

        df_header = working_set['df_output_dict']['df_header']

        dev_output_dict = {}
        for m in working_set['df_output_dict'].keys():
            if (m == 'df_header'):
                continue
            fs = working_set["df_output_dict"][m]
            dev_output_dict[fs['Filesystem']] = fs

        if (not '-T' in df_arg_list and not '--print-type' in df_arg_list):
            print('%s %s %s %s %s %s' 
                % ( df_header['Filesystem'].ljust(max(max_len['Filesystem'], 14)),
                    df_header['Size'].rjust(max_len['Size']),
                    df_header['Used'].rjust(max_len['Used']),
                    df_header['Available'].rjust(max_len['Available']),
                    df_header['Use%'].rjust(max_len['Use%']),
                    df_header['Mounted on'].rjust(max_len['Mounted on'])
                    ), file=sys.stdout)
            for k in sorted(dev_output_dict.keys()):
                fs = dev_output_dict[k]
                print('%s %s %s %s %s %s' 
                    % ( fs['Filesystem'].ljust(max(max_len['Filesystem'], 14)),
                        fs['Size'].rjust(max_len['Size']),
                        fs['Used'].rjust(max_len['Used']),
                        fs['Available'].rjust(max_len['Available']),
                        fs['Use%'].rjust(max_len['Use%']),
                        fs['Mounted on'].ljust(max_len['Mounted on'])
                        ), file=sys.stdout)
        else:
            print('%s %s %s %s %s %s %s'
                % ( df_header['Filesystem'].ljust(max(max_len['Filesystem'], 14)),
                    df_header['Type'].ljust(max_len['Type']),
                    df_header['Size'].rjust(max_len['Size']),
                    df_header['Used'].rjust(max_len['Used']),
                    df_header['Available'].rjust(max_len['Available']),
                    df_header['Use%'].rjust(max_len['Use%']),
                    df_header['Mounted on'].rjust(max_len['Mounted on'])
                    ), file=sys.stdout)
            for k in sorted(dev_output_dict.keys()):
                fs = dev_output_dict[k]
                print('%s %s %s %s %s %s %s'
                    % ( fs['Filesystem'].ljust(max(max_len['Filesystem'], 14)),
                        fs['Type'].ljust(max_len['Type']),
                        fs['Size'].rjust(max_len['Size']),
                        fs['Used'].rjust(max_len['Used']),
                        fs['Available'].rjust(max_len['Available']),
                        fs['Use%'].rjust(max_len['Use%']),
                        fs['Mounted on'].ljust(max_len['Mounted on'])
                        ), file=sys.stdout)
                
        return 0


    working_set = dict()

    scan_btrfs(parse_args, working_set)

    convert_args(parse_args, working_set)


    # 1) Run df with -T, capture out put
    exit_code = run_df(parse_args, working_set)

    # 2) Get btrfs mount points
    exit_code = get_btrfs_mounts(parse_args, working_set)

    # 3) For each btrfs FS run btrfs filesystem df
    # 4) Analyse btrfs fi df output
    # 5) Put into df output
    exit_code = do_btrfs_fi_df(parse_args, working_set)

    # 6) For each btfrs FS run btrfs qgroup show
    # 7) Analyse btrfs qgroup show output
    # 8) Insert output into congolmerated output
    exit_code = do_btrfs_quota_display(parse_args, working_set)

    # Do btrfs file system show
    exit_code = do_btrfs_filesystem_show(parse_args, working_set)

    # 9) Display congolmerated output
    exit_code = display_output(parse_args, working_set)

    return exit_code

if (os.geteuid() != 0):
    print("%s: You need to be at least suid root to run this program." % progname,
            file=sys.stderr)
    sys.exit(os.EX_NOPERM)

btrfs_tools_version = get_btrfs_tools_version()

argc = len(sys.argv)
argv = sys.argv
if (argc >= 3 and  argv[1] == 'qgroup' and argv[2] == 'limit'):
    if (btrfs_tools_version >= BTRFS_QGROUP_LIMIT_DISPLAY_VER):
        exit_code = os.execvpe(BTRFS, argv, os.environ)
	sys.exit(exit_code)
    parse_args = parse_qgroup_limit_args()
    exit_code = do_qgroup_limit(parse_args)
elif (argc >= 3 and argv[1] =='qgroup' and argv[2] == 'display'):
    parse_args = parse_quota_display_args()
    exit_code = do_quota_display(parse_args)
elif (argc >= 3 and argv[1] =='qgroup' and argv[2] == 'prune'):
    parse_args = parse_qgroup_prune_args()
    exit_code = do_qgroup_prune(parse_args)
elif (argc >= 2 and argv[1] == 'df'):
    parse_args = parse_df_args()
    exit_code = do_df(parse_args)
else:
    exit_code = os.execvpe(BTRFS, argv, os.environ)

sys.exit(exit_code)
    

